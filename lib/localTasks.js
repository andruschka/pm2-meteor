// Generated by CoffeeScript 2.2.4
(function() {
  var CWD, _settings, abs, exec, fs, getAppSrc, inquirer, isGitProject, nodemiral, path, reapplyMeteorSettings, url;

  fs = require('fs');

  ({exec} = require('child_process'));

  path = require('path');

  nodemiral = require('nodemiral');

  url = require('url');

  abs = require('abs');

  inquirer = require('inquirer');

  _settings = require('./settings');

  CWD = process.cwd();

  isGitProject = function(pm2mConf) {
    if (!pm2mConf.appLocation.local || pm2mConf.appLocation.local.trim() === "") {
      return true;
    } else {
      return false;
    }
  };

  reapplyMeteorSettings = function(pm2mConf) {
    var err, meteorSettingsLocation, meteorSettingsObj, pm2EnvLocation, pm2EnvObj, prettyJson;
    if (isGitProject(pm2mConf) && pm2mConf.meteorSettingsInRepo) {
      if (pm2mConf.meteorSettingsLocation && pm2mConf.meteorSettingsLocation !== "") {
        meteorSettingsObj = {};
        meteorSettingsLocation = path.join(CWD, _settings.gitDirName, pm2mConf.meteorSettingsLocation);
        pm2EnvLocation = path.join(CWD, _settings.pm2EnvConfigName);
        try {
          meteorSettingsObj = require(meteorSettingsLocation);
          pm2EnvObj = require(pm2EnvLocation);
          pm2EnvObj.apps[0].env["METEOR_SETTINGS"] = meteorSettingsObj;
          prettyJson = JSON.stringify(pm2EnvObj, null, 2);
          fs.writeFileSync(_settings.pm2EnvConfigName, prettyJson);
        } catch (error) {
          err = error;
          console.log(err.message);
          return false;
        }
      }
    }
    return true;
  };

  // Local tasks
  getAppSrc = module.exports = {
    initPM2MeteorSettings: function(done) {
      var json, p, prompt, questions;
      json = _settings.pm2MeteorConfigTemplate;
      questions = _settings.inquirerQuestions;
      prompt = inquirer.createPromptModule();
      p = prompt(questions);
      return p.then(function(answers) {
        var MONGO_URL, PORT, ROOT_URL, appLocation, appName, err, host, instances, meteorBuildFlags, meteorSettingsLocation, password, pem, prettyJson, username;
        ({appName, appLocation, meteorSettingsLocation, meteorBuildFlags} = answers);
        ({
          rootURL: ROOT_URL,
          port: PORT,
          mongoURL: MONGO_URL
        } = answers);
        ({
          serverHost: host,
          serverUsername: username,
          serverPassword: password,
          serverPem: pem,
          serverInstances: instances
        } = answers);
        json = Object.assign(json, {appName, appLocation, meteorSettingsLocation, meteorBuildFlags});
        json.env = Object.assign(json.env, {ROOT_URL, PORT, MONGO_URL});
        json.server = Object.assign(json.server, {host, username, password, pem, instances});
        prettyJson = JSON.stringify(json, null, 2);
        try {
          fs.writeFileSync(_settings.pm2MeteorConfigName, prettyJson);
        } catch (error) {
          err = error;
          done(err);
        }
        return done();
      });
    },
    generatePM2EnvironmentSettings: function(pm2mConf, done) {
      var appJson, envJson, err, meteorSettingsLocation, meteorSettingsObj, prettyJson, ref;
      envJson = _settings.pm2EnvConfigTemplate;
      appJson = {};
      // Fill appJson
      appJson.name = pm2mConf.appName;
      appJson.env = pm2mConf.env;
      appJson.script = path.join(pm2mConf.server.deploymentDir, pm2mConf.appName, "bundle/main.js");
      appJson.exec_mode = pm2mConf.server.exec_mode;
      appJson.instances = pm2mConf.server.instances;
      if (pm2mConf.server.interpreter && pm2mConf.server.interpreter !== "") {
        appJson.interpreter = pm2mConf.server.interpreter;
      }
      if (pm2mConf.server.log_date_format && pm2mConf.server.log_date_format !== "") {
        appJson.log_date_format = pm2mConf.server.log_date_format;
      }
      // get Meteor settings
      meteorSettingsObj = {};
      if (pm2mConf.meteorSettingsLocation && !pm2mConf.meteorSettingsInRepo) {
        try {
          meteorSettingsLocation = abs(pm2mConf.meteorSettingsLocation);
          meteorSettingsObj = JSON.parse(fs.readFileSync(meteorSettingsLocation, 'utf8'));
        } catch (error) {
          err = error;
          done(err);
        }
      }
      appJson.env["METEOR_SETTINGS"] = meteorSettingsObj;
      envJson.apps.push(appJson);
      if (pm2mConf.server.exec_mode && pm2mConf.server.exec_mode === 'fork_mode' && pm2mConf.server.instances > 1) {
        if (pm2mConf.server.freePorts && (pm2mConf.server.freePorts.length >= pm2mConf.server.instances - 1)) {
          (function() {
            var results = [];
            for (var i = 1, ref = pm2mConf.server.instances - 1; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--){ results.push(i); }
            return results;
          }).apply(this).forEach(function(ind) {
            var anotherAppJson;
            anotherAppJson = JSON.parse(JSON.stringify(appJson));
            anotherAppJson.name = `${anotherAppJson.name}-${ind + 1}`;
            anotherAppJson.env.PORT = pm2mConf.server.freePorts[ind - 1];
            anotherAppJson.instances = 1;
            return envJson.apps.push(anotherAppJson);
          });
          envJson.apps[0].name = `${envJson.apps[0].name}-1`;
          envJson.apps[0].instances = 1;
        } else {
          done(new Error('You should define server.freePorts with min. as much ports as server.instances!'));
        }
      }
      prettyJson = JSON.stringify(envJson, null, 2);
      try {
        fs.writeFileSync(_settings.pm2EnvConfigName, prettyJson);
      } catch (error) {
        err = error;
        done({
          message: `${err.message}`
        });
      }
      return done();
    },
    bundleApplication: function(pm2mConf, done) {
      if (isGitProject(pm2mConf)) {
        return this.bundleGitApplication(pm2mConf, done);
      } else {
        return this.bundleLocalApplication(pm2mConf, done);
      }
    },
    bundleLocalApplication: function(pm2mConf, done) {
      var buildScript;
      buildScript = "";
      if (pm2mConf.prebuildScript && pm2mConf.prebuildScript.trim() !== "") {
        buildScript += `cd ${abs(pm2mConf.appLocation.local)} && ${pm2mConf.prebuildScript} && `;
      }
      buildScript += `cd ${abs(pm2mConf.appLocation.local)} && meteor build ${pm2mConf.meteorBuildFlags} --directory ${CWD}`;
      return exec(buildScript, function(err, stdout, stderr) {
        if (err) {
          return done(err);
        } else {
          buildScript = `cd ${CWD} && tar -zcvf ${_settings.bundleTarName} ${_settings.bundleName} ${_settings.pm2EnvConfigName}`;
          return exec(buildScript, {
            maxBuffer: 1024 * 200000
          }, function(err, stdout, stderr) {
            if (err) {
              return done(err);
            } else {
              return done();
            }
          });
        }
      });
    },
    bundleGitApplication: function(pm2mConf, done) {
      return exec(`cd ${CWD} && git clone ${pm2mConf.appLocation.git} --branch ${pm2mConf.appLocation.branch} ${_settings.gitDirName}`, function(err, stdout, stderr) {
        var buildScript;
        if (err) {
          return done(err);
        } else {
          if (reapplyMeteorSettings(pm2mConf) === false) {
            return done({
              message: "Something went wrong wihile building METEOR_SETTINGS"
            });
          } else {
            buildScript = `cd ${path.join(CWD, _settings.gitDirName)} `;
            if (pm2mConf.prebuildScript && pm2mConf.prebuildScript.trim() !== "") {
              buildScript += `&& ${pm2mConf.prebuildScript} `;
            }
            buildScript += `&& meteor build ${pm2mConf.meteorBuildFlags} --directory ${CWD}`;
            return exec(buildScript, function(err, sdout, stderr) {
              if (err) {
                return done(err);
              } else {
                return exec(`cd ${CWD} && tar -zcvf ${_settings.bundleTarName} ${_settings.bundleName} ${_settings.pm2EnvConfigName}`, {
                  maxBuffer: 1024 * 200000
                }, function(err, stdout, stderr) {
                  if (err) {
                    return done(err);
                  } else {
                    return done();
                  }
                });
              }
            });
          }
        }
      });
    },
    makeClean: function(done) {
      return exec(`cd ${CWD} && rm -rf ${_settings.bundleName} && rm ${_settings.pm2EnvConfigName} && rm ${_settings.bundleTarName} && rm -rf ${_settings.gitDirName}`, function(err, stdout, stderr) {
        if (err) {
          return done(err);
        } else {
          return done();
        }
      });
    },
    makeCleanAndLeaveBundle: function(done) {
      return exec(`cd ${CWD} && rm -rf ${_settings.bundleName} && rm ${_settings.pm2EnvConfigName} && rm -rf ${_settings.gitDirName}`, function(err, stdout, stderr) {
        if (err) {
          return done(err);
        } else {
          return done();
        }
      });
    }
  };

}).call(this);
